// BASED ON THE "EXTREM C BOOK - 1 EDITION"
// Code was tested with gcc

#include <stdio.h>

/**
 * Do not believe in those who say C cannot be OOP because it is to old, then ask why is still alive
 * and C++ was written above it. Also, it is not the case that C is dead, then why not OOP even with 
 * its modern update?
 * 
 * Simple, a CPU is procedural, not like an human and its conception of the world. This creates the 
 * need to execute the process in a list of steps (commands) which is related to the C structure and 
 * C is in the middle of OOP and procedural programming, and its needed or no one could link the CPU 
 * with the high-level programs.
 * 
 * And if you think that the previous info is wrong, then you should check the layers of languages
 * like Jave, Python... which have a C bridge to its libraries or environments for traslation to low
 * level instructions.
*/

int main(int argc, char **argv)
{
    printf("C is in the middle of 2 worlds, OOP and procedural Programming...\n");
    printf("Remember, your CPU just understand low-level instructions which you do not know...\n");
    printf("Then, when you forget about this importance... check the compilation of C...");
    printf("   gcc -S <your code> ");
    return 0;
}
